<html lang="da">
<head>
  <script src="gate.js"></script>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Rutebygger - NKL</title>
  <link rel="stylesheet" href="css/base.css" /> 
  <link rel="stylesheet" href="css/menu.css" />
</head>
<body>
<div class="kort">
  <h2>üßó Upload billede og opret rute</h2>

  <label for="imgInput">üì∑ V√¶lg billede(OBS overskriver det gamle)</label>
  <input type="file" id="imgInput" accept="image/*" />

  <label for="eksisterendeBilleder">üìÅ Eller v√¶lg eksisterende billede</label>
  <select id="eksisterendeBilleder">
    <option value="">üìÅ V√¶lg eksisterende billede</option>
  </select>

  <p id="status">Ingen billede valgt endnu</p>
</div>

<div class="kort" id="ruteForm">
  <h2>üßó Opret ny rute</h2>

  <label for="rutenavn">Navn p√• rute</label>
  <input type="text" id="rutenavn" placeholder="Navn p√• rute" />
  
  <div class="navn-generator">
  <button type="button" id="foresl√•-navn" class="primary">üé≤ Foresl√• navn</button>
  <div id="navneforslag" class="forslagscontainer hidden"></div>
  </div>


  <label for="rutefarve">Farve</label>
  <select id="rutefarve">
    <option value="grey">Gr√•</option>
    <option value="red">R√∏d</option>
    <option value="green">Gr√∏n</option>
    <option value="blue">Bl√•</option>
    <option value="orange">Orange</option>
    <option value="purple">Lilla</option>
    <option value="black">Sort</option>
    <option value="yellow">Gul</option>
    <option value="white">Hvid</option>
    <option value="pink">Pink</option>
    <option value="mint">Mint</option>
  </select>

  <label for="rutegrad">Grad</label>
  <select id="rutegrad">
    <option value="">Grad</option>
    <option>4</option>
    <option>5a</option>
    <option>5b</option>
    <option>5c</option>
    <option>6a</option>
    <option>6a+</option>
    <option>6b</option>
    <option>6b+</option>
    <option>6c</option>
    <option>6c+</option>
    <option>7a</option>
    <option>7a+</option>
    <option>7b</option>
    <option>7b+</option>
    <option>7c</option>
  </select>

  <label for="rutebygger">Rutebygger</label>
  <input type="text" id="rutebygger" placeholder="Navn p√• rutebygger" />

  <label for="billedeIdValg">V√¶lg v√¶g/sektor</label>
  <select id="billedeIdValg">
    <!-- Bouldere -->
    <option value="sektor-a">Sektor A</option>
    <option value="sektor-b">Sektor B</option>
    <option value="sektor-c">Sektor C</option>
    <option value="sektor-d">Sektor D</option>
    <!-- H√∏jv√¶g -->
    <option value="anker-a">Anker 1-2-3-4</option>
    <option value="anker-b">Anker 5-6-7</option>
    <option value="anker-c">Anker 8-9-10</option>
	<option value="anker-d">Anker 11-12-13</option>
	<option value="anker-e">Anker 14-15-16-17</option>
	<option value="anker-f">Anker 18-19-20-21-22</option>
  </select>

  <label>
    <input type="checkbox" id="ruteAktiv" checked />
    Aktiv rute (synlig i oversigt)
  </label>

  <div class="tool-actions">
    <button id="gemKnap">‚úÖ Gem rute</button>
    <button id="deaktiverAlleKnap">üö´ G√∏r alle ruter inaktive</button>
	<button id="nulstilGrebKnap" type="button">üßπ Nulstil greb</button>
    <button onclick="fortrydSidste()">‚Ü©Ô∏è Fortryd sidste greb</button>
    <button onclick="rydValg()">üóëÔ∏è Ryd valg</button>
	<button id="visAlleRuterKnap">üëÅÔ∏è Vis alle gemte ruter</button>
    <button id="toggleGrebKnap">üîç Vis alle greb</button>
	<button id="nulstilZoomKnap">üîÑ Nulstil visning</button>
  </div>
</div>

<div id="canvas-loader" class="canvas-loader hidden">
  <div class="spinner"></div>
</div>

<div id="canvas-container">
  <div id="redigerStatus" class="rediger-boks skjult"></div>
  <canvas id="canvas"></canvas>
</div>

<div class="kort">
  <h2 id="ruteOverskrift"></h2>
  <div id="ruteListe"></div>
</div>


<script type="module">
	import { client, adgangskontrol, inds√¶tMenu, hentPublicUrlMedCache } from './auth.js';

  adgangskontrol({
    tilladteRoller: [],
    redirectVedFejl: "index.html",
    efterLogin: (bruger) => {
	  if (window.releaseAuthGate) window.releaseAuthGate();
      inds√¶tMenu(bruger);
	  udfyldEksisterendeBillederDropdown();
	  aktuelBruger = bruger;
	  udfyldBilledeDropdownFraRuter();
      const brugerNavnEl = document.getElementById("bruger-navn");
if (brugerNavnEl) {
  brugerNavnEl.textContent = (bruger?.navn || "Ukendt");
}
    }
  });


async function hentRuter() {
  const { data, error } = await client
    .from("ruter")
    .select("*");

  if (error) {
    console.error("‚ùå Kunne ikke hente ruter:", error);
    return;
  }

  gemteRuter = data;
  opdaterRuteListe();
}

  let aktuelBruger = null;
  let allPredictions = [];
  let valgtRute = [];
  let gemteRuter = [];
  let img, canvas, ctx;
  let visAlleGreb = false;
  let baseNavn = "";
  let redigeretRuteId = null;
  let zoom = 1;
  let offsetX = 0;
  let offsetY = 0;
  let isDragging = false;
  let dragStart = { x: 0, y: 0 };

// --- Mobil/Touch support (Pointer Events + pinch-zoom) ---
// Aktiv pointere til pinch-zoom mm.
const activePointers = new Map();
let pinchStartDist = 0;
let pinchStartZoom = 1;
let pinchStartOffset = { x: 0, y: 0 };
let pinchCenter = { x: 0, y: 0 };
let tapCandidate = null;           // til at skelne pan vs. tap
const TAP_MAX_MOVEPX = 8;
const TAP_MAX_TIME = 300;          // ms

function getCanvasXY(evt) {
  const rect = canvas.getBoundingClientRect();
  // Sk√¶rm ‚Üí canvas CSS-koordinater
  const cssX = evt.clientX - rect.left;
  const cssY = evt.clientY - rect.top;

  // CSS ‚Üí bitmap pixels (hvis du tegner i ‚Äúdevice pixels‚Äù)
  const scaleX = canvas.width  / rect.width;
  const scaleY = canvas.height / rect.height;
  const pxX = cssX * scaleX;
  const pxY = cssY * scaleY;

  // Pga. zoom/offset (du tegner billedet i world-space (0,0) s√• pan/zoom flytter koordinaterne)
  const worldX = (pxX - offsetX) / zoom;
  const worldY = (pxY - offsetY) / zoom;

  return { cssX, cssY, pxX, pxY, worldX, worldY };
}

function dist(a, b) {
  const dx = a.clientX - b.clientX;
  const dy = a.clientY - b.clientY;
  return Math.hypot(dx, dy);
}

function mid(a, b) {
  return { x: (a.clientX + b.clientX)/2, y: (a.clientY + b.clientY)/2 };
}

// Hit-test: tjek om et punkt er inde i en polygon (Roboflow-polygons)
function pointInPoly(pt, poly) {
  // poly: array [{x,y},...] eller [[x,y],...]
  let inside = false;
  for (let i = 0, j = poly.length - 1; i < poly.length; j = i++) {
    const xi = poly[i].x ?? poly[i][0];
    const yi = poly[i].y ?? poly[i][1];
    const xj = poly[j].x ?? poly[j][0];
    const yj = poly[j].y ?? poly[j][1];
    const intersect = ((yi > pt.y) !== (yj > pt.y)) &&
      (pt.x < (xj - xi) * (pt.y - yi) / ((yj - yi) || 1e-9) + xi);
    if (intersect) inside = !inside;
  }
  return inside;
}

function toggleHoldAt(worldX, worldY) {
  if (!Array.isArray(allPredictions)) return;

  // Find f√∏rste polygon der rammes
  const hit = allPredictions.find(p => {
    const poly = (p?.points || p?.polygon || p?.segmentation || []).map(([x,y]) => ({x, y}));
    return poly.length >= 3 && pointInPoly({x: worldX, y: worldY}, poly);
  });

  if (!hit) return;

  // Brug fx id/center til at identificere valget
  const holdId = hit?.id || `${hit.class}-${Math.round(hit.x)}-${Math.round(hit.y)}`;
  const i = valgtRute.indexOf(holdId);
  if (i >= 0) {
    valgtRute.splice(i, 1);
  } else {
    valgtRute.push(holdId);
  }
  drawSelection();
}

function onPointerDown(e) {
  canvas.setPointerCapture(e.pointerId);
  activePointers.set(e.pointerId, e);

  if (activePointers.size === 1) {
    // start mulig tap/pan
    const now = performance.now();
    tapCandidate = { x: e.clientX, y: e.clientY, t: now };
    isDragging = true;
    const { pxX, pxY } = getCanvasXY(e);
    dragStart = { x: pxX - offsetX, y: pxY - offsetY }; // husk relativt til offset
  } else if (activePointers.size === 2) {
    // pinch start
    const [p1, p2] = [...activePointers.values()];
    pinchStartDist = dist(p1, p2);
    pinchStartZoom = zoom;
    pinchStartOffset = { x: offsetX, y: offsetY };
    const m = mid(p1, p2);
    const rect = canvas.getBoundingClientRect();
    // Pinch-center i canvas *pixel*-space:
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;
    pinchCenter = { x: (m.x - rect.left) * scaleX, y: (m.y - rect.top) * scaleY };
  }

  e.preventDefault();
}

function onPointerMove(e) {
  if (!activePointers.has(e.pointerId)) return;
  activePointers.set(e.pointerId, e);

  if (activePointers.size === 1 && isDragging) {
    // Pan
    const { pxX, pxY } = getCanvasXY(e);
    offsetX = pxX - dragStart.x;
    offsetY = pxY - dragStart.y;
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.save();
    ctx.translate(offsetX, offsetY);
    ctx.scale(zoom, zoom);
    ctx.drawImage(img, 0, 0);
    ctx.restore();
    drawSelection();
  }
  else if (activePointers.size === 2) {
    // Pinch-zoom (skaler omkring pinchCenter)
    const [p1, p2] = [...activePointers.values()];
    const d = dist(p1, p2);
    if (pinchStartDist > 0) {
      const factor = d / pinchStartDist;
      const newZoom = Math.min(6, Math.max(0.3, pinchStartZoom * factor));

      // just√©r offset, s√• pinchCenter holder sig ‚Äúfast‚Äù
      // world-koordinat for pinchCenter f√∏r/efter zoom:
      const beforeWorldX = (pinchCenter.x - pinchStartOffset.x) / pinchStartZoom;
      const beforeWorldY = (pinchCenter.y - pinchStartOffset.y) / pinchStartZoom;
      offsetX = pinchCenter.x - beforeWorldX * newZoom;
      offsetY = pinchCenter.y - beforeWorldY * newZoom;
      zoom = newZoom;

      ctx.clearRect(0,0,canvas.width,canvas.height);
      ctx.save();
      ctx.translate(offsetX, offsetY);
      ctx.scale(zoom, zoom);
      ctx.drawImage(img, 0, 0);
      ctx.restore();
      drawSelection();
    }
  }

  e.preventDefault();
}

function onPointerUp(e) {
  if (activePointers.has(e.pointerId)) {
    activePointers.delete(e.pointerId);
  }

  // Tap-detektion (kun hvis der ikke er pinch og det var en stille kort bev√¶gelse)
  if (activePointers.size === 0) {
    canvas.releasePointerCapture(e.pointerId);
    if (tapCandidate) {
      const moved = Math.hypot(e.clientX - tapCandidate.x, e.clientY - tapCandidate.y);
      const dt = performance.now() - tapCandidate.t;
      if (moved <= TAP_MAX_MOVEPX && dt <= TAP_MAX_TIME) {
        const { worldX, worldY } = getCanvasXY(e);
        toggleHoldAt(worldX, worldY);
      }
      tapCandidate = null;
    }
    isDragging = false;
    pinchStartDist = 0;
  }

  e.preventDefault();
}

function onPointerCancel(e) {
  activePointers.delete(e.pointerId);
  isDragging = false;
  tapCandidate = null;
  pinchStartDist = 0;
}

function setupPointerEvents() {
  // Fjern evt. gamle mouse/touch-lyttere hvis du havde s√•dan nogle (valgfrit)
 // canvas.onpointerdown = onPointerDown;
 // canvas.onpointermove = onPointerMove;
 // canvas.onpointerup = onPointerUp;
 // canvas.onpointercancel = onPointerCancel;
}

// Kald denne n√•r canvas + img er klar (du g√∏r det efter load af billede i dine eksisterende flows)
setupPointerEvents();


function hexToRgba(color, alpha = 0.3) {
  const ctx = document.createElement("canvas").getContext("2d");
  ctx.fillStyle = color;
  const computed = ctx.fillStyle;

  // Nu har vi farven som rgb(...) ‚Äì vi udskifter 'rgb' med 'rgba'
  return computed.replace("rgb(", "rgba(").replace(")", `, ${alpha})`);
}

document.getElementById("eksisterendeBilleder").addEventListener("change", async function (e) {
  const valgtFil = e.target.value;
  baseNavn = valgtFil.replace(/\.[^/.]+$/, "");

  const billedeUrl = hentPublicUrlMedCache(valgtFil);
  if (!billedeUrl) {
  alert("‚ùå Kunne ikke hente billedet.");
  return;
  }

  // Hent billedet som blob
  const response = await fetch(billedeUrl);
  const blob = await response.blob();

  // Konverter til base64
  const reader = new FileReader();
  reader.onloadend = async function () {
  // Vis loading
  document.getElementById("canvas-loader")?.classList.remove("hidden");

  const base64Image = reader.result.split(",")[1];

  const roResponse = await fetch("https://serverless.roboflow.com/infer/workflows/climbing-holds-etzec/findgrebpolygon", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({
      api_key: "rmYgUFzqbYEM2ziXw75d",
      inputs: {
        image: { type: "base64", value: base64Image }
      }
    })
  });

  const result = await roResponse.json();
  allPredictions = result.outputs?.[0]?.predictions?.predictions || [];

  // Vis billedet
  img = new Image();
  img.src = billedeUrl;
  await img.decode();

  canvas = document.getElementById("canvas");
  ctx = canvas.getContext("2d");
  canvas.width = img.width;
  canvas.height = img.height;
  ctx.drawImage(img, 0, 0);

  valgtRute = [];

  // Opdater dropdown
  const idValg = document.getElementById("billedeIdValg");
  const match = Array.from(idValg.options).find(opt => opt.value === baseNavn);
  if (match) idValg.value = baseNavn;

  drawSelection();
  await hentRuter();

  document.getElementById("status").textContent = `‚úÖ Greb l√¶st for ${valgtFil} ‚Äì klik for at markere`;

  // Skjul loading
  document.getElementById("canvas-loader")?.classList.add("hidden");
};

  reader.readAsDataURL(blob);
});

document.getElementById("imgInput").addEventListener("change", async function (e) {
  const file = e.target.files[0];
  if (!file) return;

  const filnavnOriginal = file.name.toLowerCase().replace(/\s+/g, "-");
  const matchKategori = filnavnOriginal.match(/^(sektor-[a-d]|anker-[a-f]|tagruter)/);

  if (!matchKategori) {
    alert("‚ùå Filnavnet skal starte med en kendt kategori som 'sektor-a', 'anker-a' eller 'tagruter'");
    return;
  }

  const kategori = matchKategori[1];
  const webpFilnavn = await konverterOgUpload(file, kategori);
  if (!webpFilnavn) return;

  baseNavn = webpFilnavn.replace(".webp", "");

  // Opdater dropdown og status
  await udfyldEksisterendeBillederDropdown();
  document.getElementById("eksisterendeBilleder").value = webpFilnavn;
  document.getElementById("status").textContent = `‚úÖ Billede uploadet som ${webpFilnavn} ‚Äì l√¶ser greb...`;

  // Hent billede fra Supabase som .webp
	const billedeUrl = hentPublicUrlMedCache(webpFilnavn);
	if (!billedeUrl) {
	alert("‚ùå Kunne ikke hente det uploadede billede.");
	return;
	}

  const response = await fetch(billedeUrl);
  const blob = await response.blob();

  // Konverter til base64 for Roboflow
  const reader = new FileReader();
  reader.onloadend = async function () {
    document.getElementById("canvas-loader")?.classList.remove("hidden");

    const base64Image = reader.result.split(',')[1];
    const roResponse = await fetch("https://serverless.roboflow.com/infer/workflows/climbing-holds-etzec/findgrebpolygon", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({
        api_key: "rmYgUFzqbYEM2ziXw75d",
        inputs: { image: { type: "base64", value: base64Image } }
      })
    });

    const result = await roResponse.json();
    allPredictions = result.outputs?.[0]?.predictions?.predictions || [];

    // Vis billede i canvas
    img = new Image();
    img.src = billedeUrl;
    await img.decode();

    canvas = document.getElementById("canvas");
    ctx = canvas.getContext("2d");
    canvas.width = img.width;
    canvas.height = img.height;
    ctx.drawImage(img, 0, 0);

    // Marker ruten og opdater status
    valgtRute = [];

    const dropdown = document.getElementById("billedeIdValg");
    const mulighed = Array.from(dropdown.options).find(opt => opt.value === kategori);
    if (mulighed) dropdown.value = kategori;

    drawSelection();
    await hentRuter();

    document.getElementById("status").textContent = `‚úÖ Greb l√¶st ‚Äì klar til at oprette rute p√• ${baseNavn}`;
    document.getElementById("canvas-loader")?.classList.add("hidden");
  };

  reader.readAsDataURL(blob);
});

// Brugeren skal v√¶lge kategori manuelt (via dropdown)
// const kategori = document.getElementById("billedeIdValg").value; // f.eks. "tagruter"
const bruger = JSON.parse(localStorage.getItem("bruger")); // eller `aktuelBruger`

async function udfyldEksisterendeBillederDropdown() {
  const { data, error } = await client
    .storage
    .from("ruter")
    .list("", { limit: 100 });

  if (error) {
    console.error("‚ùå Kunne ikke hente eksisterende billeder:", error);
    return;
  }

  const dropdown = document.getElementById("eksisterendeBilleder");
  dropdown.innerHTML = '<option value="">üìÅ V√¶lg eksisterende billede</option>';

  const senestePerKategori = {};

  data
    .filter(f => f.name.match(/\.webp$/i))
    .forEach(f => {
      const navnUdenExt = f.name.replace(/\.[^/.]+$/, "");
      const [kategori, dato] = navnUdenExt.split("_");

      if (!dato || !kategori) return;

      if (!senestePerKategori[kategori] || dato > senestePerKategori[kategori].dato) {
        senestePerKategori[kategori] = { navn: f.name, dato };
      }
    });

  // Sort√©r alfabetisk efter kategori
  const sorterede = Object.entries(senestePerKategori).sort(([a], [b]) => a.localeCompare(b));

  sorterede.forEach(([, { navn }]) => {
    const option = document.createElement("option");
    option.value = navn;
    option.textContent = navn;
    dropdown.appendChild(option);
  });
}

async function udfyldBilledeDropdownFraRuter() {
  const { data, error } = await client
    .from("ruter")
    .select("billede_id")
    .neq("billede_id", "")
    .order("billede_id", { ascending: true });

  if (error) {
    console.error("‚ùå Kunne ikke hente billede_id fra ruter:", error);
    return;
  }

  // üß© Ekstra: kendte kategorier der skal vises som fallback
  const fallbackKategorier = [
    "sektor-a", "sektor-b", "sektor-c", "sektor-d",
    "anker-a", "anker-b", "anker-c", "anker-d", "anker-e", "anker-f",
    "tagruter"
  ];

  // Kombiner ruter fra databasen med fallback-kategorier
  const unikke = [...new Set([
    ...data.map(r => r.billede_id),
    ...fallbackKategorier
  ])].sort();

  const dropdown = document.getElementById("billedeIdValg");
  dropdown.innerHTML = '<option value="">V√¶lg v√¶g</option>';

  unikke.forEach(id => {
    const option = document.createElement("option");
    option.value = id;
    option.textContent = id;
    dropdown.appendChild(option);
  });
}

async function konverterOgUpload(fil, kategori) {
  try {
    // 1. Konverter til .webp
    const bitmap = await createImageBitmap(fil);
    const canvas = document.createElement('canvas');
    canvas.width = bitmap.width;
    canvas.height = bitmap.height;
    const ctx = canvas.getContext('2d');
    ctx.drawImage(bitmap, 0, 0);

    const webpBlob = await new Promise(resolve =>
      canvas.toBlob(resolve, 'image/webp', 0.85)
    );

    // 2. Navngivning: eks. sektor-a_2025-08-02.webp
	const now = new Date();
	const dato = now.toISOString().slice(0,10);                
	const tid  = [now.getHours(), now.getMinutes()] 
					.map(n => String(n).padStart(2, "0")).join("-"); 
	const filnavn = `${kategori}_${dato}_${tid}.webp`;
    const sti = `${filnavn}`;

    // 3. Upload til Supabase Storage
    const { error: uploadError } = await client.storage
      .from('ruter')
      .upload(sti, webpBlob, {
        contentType: 'image/webp',
        upsert: true,
      });

    if (uploadError) throw uploadError;

    // 4. (Valgfrit) Slet original filnavn hvis uploadet manuelt
    const originalNavn = fil.name;
    const originalSti = `${originalNavn}`;
    await client.storage.from('ruter').remove([originalSti]);

    console.log(`‚úÖ Webp-billede uploadet som ${filnavn}`);
    return filnavn; // vigtigt: skal gemmes i din rute med feltet billede_url
  } catch (err) {
    console.error("‚ùå Fejl ved billedkonvertering:", err);
    alert("Kunne ikke konvertere billede.");
    return null;
  }
}

const gradR√¶kkef√∏lge = [
  "4","5a","5b","5c","6a","6a+","6b","6b+","6c","6c+",
  "7a","7a+","7b","7b+","7c"
];

function beregnBasePoints(grad) {
  const k = gradR√¶kkef√∏lge.indexOf((grad||"").toLowerCase());
  if (k < 0) return 0;
  return Math.round(5 * Math.pow(1.32, k));
}

function opdaterOverskrift() {
  const overskrift = document.getElementById("ruteOverskrift");
  const sektor = document.getElementById("billedeIdValg").value;

  if (["sektor-a", "sektor-b", "sektor-c", "sektor-d"].includes(sektor)) {
    overskrift.textContent = "üìã Gemte bouldere";
  } else {
    overskrift.textContent = "üìã Gemte ruter";
  }
}

function pointInPolygon(x, y, polygon) {
  let inside = false;

  for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
    const xi = polygon[i][0], yi = polygon[i][1];
    const xj = polygon[j][0], yj = polygon[j][1];

    const intersect = ((yi > y) !== (yj > y)) &&
                      (x < (xj - xi) * (y - yi) / ((yj - yi) || 1e-10) + xi);
    if (intersect) inside = !inside;
  }

  return inside;
}

function drawPolygon(ctx, points, color = "cyan") {
  if (!points || points.length < 3) return;

  // Konverter fra {x, y} til [x, y] hvis n√∏dvendigt
  if (typeof points[0] === "object" && points[0].x !== undefined) {
    points = points.map(p => [p.x, p.y]);
  }

  ctx.save();
  ctx.beginPath();
  ctx.lineJoin = "round";
  ctx.lineCap = "round";

  // Start midt mellem f√∏rste og andet punkt
  ctx.moveTo((points[0][0] + points[1][0]) / 2, (points[0][1] + points[1][1]) / 2);

  for (let i = 1; i < points.length - 1; i++) {
    const xc = (points[i][0] + points[i + 1][0]) / 2;
    const yc = (points[i][1] + points[i + 1][1]) / 2;
    ctx.quadraticCurveTo(points[i][0], points[i][1], xc, yc);
  }

  // Slut af med kurve til f√∏rste punkt
  ctx.quadraticCurveTo(
    points[points.length - 1][0],
    points[points.length - 1][1],
    (points[0][0] + points[points.length - 1][0]) / 2,
    (points[0][1] + points[points.length - 1][1]) / 2
  );

  ctx.closePath();
  ctx.strokeStyle = color;
  ctx.lineWidth = 2;
  ctx.stroke();
  
  ctx.restore();
}

function drawSelection() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  ctx.save();
  ctx.translate(offsetX, offsetY);
  ctx.scale(zoom, zoom);
  ctx.drawImage(img, 0, 0);

  if (visAlleGreb) {
    allPredictions.forEach(p => drawSingleHold(p));
  }

  valgtRute.forEach(p => drawSingleHold(p, "magenta"));
  ctx.restore();
}

function drawSingleHold(p, overrideColor = null) {
  const { points } = p;

  let strokeColor = overrideColor;

  if (!strokeColor) {
  strokeColor = visAlleGreb ? "lime" : "magenta";
  }


  const isMobile = window.innerWidth <= 600;
  ctx.save();

  ctx.lineWidth = isMobile ? 4 : 2;
  ctx.strokeStyle = strokeColor;

  // Shadow kun hvis det ikke er "vis alle greb"
  ctx.shadowColor = visAlleGreb ? "transparent" : "black";
  ctx.shadowBlur = visAlleGreb ? 0 : (isMobile ? 4 : 2);

  // === Tegn polygon ===
  if (Array.isArray(points) && points.length >= 3) {
    ctx.beginPath();

    if (Array.isArray(points[0])) {
      ctx.moveTo(points[0][0], points[0][1]);
      for (let i = 1; i < points.length; i++) {
        ctx.lineTo(points[i][0], points[i][1]);
      }
    } else {
      ctx.moveTo(points[0].x, points[0].y);
      for (let i = 1; i < points.length; i++) {
        ctx.lineTo(points[i].x, points[i].y);
      }
    }

    ctx.closePath();
    ctx.stroke();
  }

  ctx.restore();
}

document.getElementById("gemKnap").addEventListener("click", async () => {
  redigeretRuteId = document.getElementById("gemKnap").dataset?.redigerId || null;
  const erRedigering = !!redigeretRuteId;

  const navn = document.getElementById("rutenavn").value.trim();
  const farve = document.getElementById("rutefarve").value;
  const grad = document.getElementById("rutegrad").value;
  const rutebygger = document.getElementById("rutebygger").value.trim();
  const billedeId = document.getElementById("billedeIdValg").value;
  const bruger = JSON.parse(localStorage.getItem("bruger"));
  const user_id = bruger?.id || null;

  if (!navn || (!erRedigering && valgtRute.length === 0)) {
    return alert("V√¶lg greb og skriv et rutenavn f√∏rst.");
  }

  try {

const ruteDerRedigeres = gemteRuter.find(r => r.id === redigeretRuteId);
const grebData = valgtRute.length > 0 ? valgtRute : ruteDerRedigeres?.greb || [];

const data = {
  navn,
  greb: grebData,
  farve,
  grad,
  rutebygger,
  aktiv: document.getElementById("ruteAktiv").checked
};

// beregn points automatisk ud fra grad
data.points = beregnBasePoints(data.grad);

    let error;

    if (redigeretRuteId) {
      // üîÅ OPDATER
      ({ error } = await client
        .from("ruter")
        .update(data)
        .eq("id", redigeretRuteId));
    } else {
      // ‚ûï OPRET NY
      data.billede_id = billedeId;
      data.billedenavn = `${baseNavn}.webp`;
      data.user_id = user_id;

      ({ error } = await client
        .from("ruter")
        .insert([data]));
    }

    if (error) throw error;

    console.log("‚úÖ Rute gemt:", navn);
    await hentRuter();
    valgtRute = [];
    drawSelection();
    redigeretRuteId = null;
	
	// Fjerner redig√©rbj√¶lken
	document.getElementById("redigerStatus").classList.add("skjult"); // üßπ skjul rediger-bj√¶lke
	document.getElementById("gemKnap").dataset.redigerId = ""; // ryd evt. ID

    // Nulstil felter
    document.getElementById("rutenavn").value = "";
    document.getElementById("rutefarve").value = "";
    document.getElementById("rutegrad").value = "";
    document.getElementById("rutebygger").value = "";
    document.getElementById("ruteAktiv").checked = true;
	

    alert("‚úÖ Ruten blev gemt og sat som aktiv for billedet.");
  } catch (err) {
    console.error("‚ùå Fejl:", err);
    alert("‚ùå Der skete en fejl under gemning.");
  }
});

function visRute(rute) {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  ctx.save();
  ctx.translate(offsetX, offsetY);
  ctx.scale(zoom, zoom);

  ctx.drawImage(img, 0, 0);

  const farve = rute.farve || "cyan";
  rute.greb.forEach(p => drawSingleHold(p, farve));

ctx.font = "30px Arial";
ctx.lineWidth = 6;
ctx.strokeStyle = "black";
ctx.fillStyle = "white";
ctx.lineJoin = "round";

const startX = 20;
let startY = 60;     
const linjeAfstand = 48; 

ctx.strokeText(`üìå ${rute.navn}`, startX, startY);
ctx.fillText(`üìå ${rute.navn}`, startX, startY);

startY += linjeAfstand;
ctx.strokeText(`üéØ ${rute.grad || "?"}`, startX, startY);
ctx.fillText(`üéØ ${rute.grad || "?"}`, startX, startY);

startY += linjeAfstand;
ctx.strokeText(`üë∑ ${rute.rutebygger || "Ukendt"}`, startX, startY);
ctx.fillText(`üë∑ ${rute.rutebygger || "Ukendt"}`, startX, startY);


  ctx.restore();
}

function redig√©rRute(rute) {
  document.getElementById("rutenavn").value = rute.navn || "";
  document.getElementById("rutefarve").value = rute.farve || "";
  document.getElementById("rutegrad").value = rute.grad || "";
  document.getElementById("rutebygger").value = rute.rutebygger || "";
  document.getElementById("ruteAktiv").checked = rute.aktiv || false;
  document.getElementById("gemKnap").dataset.redigerId = rute.id;
  redigeretRuteId = rute.id;
  valgtRute = [...rute.greb]; 

  // üëá Vis status √∏verst
  const statusEl = document.getElementById("redigerStatus");
  statusEl.classList.remove("skjult");
  statusEl.innerHTML = `
    ‚úèÔ∏è Redigerer: <strong>${rute.navn}</strong> (${rute.grad || "?"}, ${rute.farve}) 
    <button class="annuller" onclick="annullerRedigering()">‚ùå Annuller</button>
  `;

  drawSelection();
}

window.annullerRedigering = function () {
  redigeretRuteId = null;
  document.getElementById("gemKnap").dataset.redigerId = "";
  valgtRute = [];
  document.getElementById("rutenavn").value = "";
  document.getElementById("rutefarve").value = "";
  document.getElementById("rutegrad").value = "";
  document.getElementById("rutebygger").value = "";
  document.getElementById("ruteAktiv").checked = true;

  // Skjul status
  document.getElementById("redigerStatus").classList.add("skjult");

  drawSelection();
};

async function sletRute(id) {
	
  // Tjek f√∏rst om ruten er logget i rutelog
  const { data: logs, error: logError } = await client
    .from("rutelog")
    .select("id")
    .eq("rute_id", id);
	
  if (logError) {
    console.error("‚ùå Fejl ved tjek af log:", logError);
    return alert("Kunne ikke tjekke om ruten er logget.");
  }

const logsFound = Array.isArray(logs) && logs.length > 0;

if (logsFound) {
  return alert("‚ùå Ruten er logget af en eller flere brugere og kan ikke slettes.");
}

  if (!confirm("Vil du slette denne rute permanent?")) return;

  const { error } = await client
    .from("ruter")
    .delete()
    .eq("id", id);

  if (error) {
    console.error("‚ùå Fejl ved sletning:", error);
    alert("Kunne ikke slette ruten.");
  } else {
    alert("‚úÖ Rute slettet.");
    await hentRuter();
    drawSelection();
  }
}

window.sletRute = sletRute;

function opdaterRuteListe() {
  const listeEl = document.getElementById("ruteListe");
  listeEl.innerHTML = "";

  const aktivtBilledeId = document.getElementById("billedeIdValg")?.value;
  if (!aktivtBilledeId) {
    listeEl.innerHTML = "<p>V√¶lg en v√¶g/sektor for at se gemte ruter.</p>";
    return;
  }

  const filtreredeRuter = gemteRuter.filter(r => r.billede_id === aktivtBilledeId && r.aktiv);

  if (filtreredeRuter.length === 0) {
    listeEl.innerHTML = "<p>Ingen ruter fundet for denne sektion.</p>";
    return;
  }

  filtreredeRuter.forEach(rute => {
    const wrapper = document.createElement("div");
    wrapper.className = "rute-item";

    const navn = document.createElement("span");

    const knapContainer = document.createElement("div");
    knapContainer.className = "rute-knapper";

    const btn = document.createElement("button");
    btn.innerHTML = `üìå ${rute.navn}`;
    btn.style.opacity = rute.aktiv ? "1" : "0.4";
    btn.title = rute.aktiv ? "Aktiv" : "Inaktiv";
    btn.addEventListener("click", () => visRute(rute));

    const redig√©r = document.createElement("button");
    redig√©r.innerHTML = "‚úèÔ∏è";
    redig√©r.title = "Redig√©r";
    redig√©r.addEventListener("click", () => redig√©rRute(rute));

    const toggle = document.createElement("button");
    toggle.innerHTML = rute.aktiv ? "üîï Skjul" : "‚úÖ Vis";
    toggle.title = "Skift aktiv-status";
    toggle.addEventListener("click", async () => {
      const { error } = await client
        .from("ruter")
        .update({ aktiv: !rute.aktiv })
        .eq("id", rute.id);

      if (error) {
        alert("Kunne ikke opdatere aktiv-status");
        console.error(error);
      } else {
        await hentRuter();
        drawSelection();
      }
    });

    const slet = document.createElement("button");
    slet.innerHTML = "üóëÔ∏è";
    slet.title = "Slet";
	slet.addEventListener("click", () => {
	sletRute(rute.id);
	});
	
    // Tilf√∏j knapper til knap-container
    knapContainer.appendChild(btn);
    knapContainer.appendChild(redig√©r);
    knapContainer.appendChild(toggle);
    knapContainer.appendChild(slet);

    // Tilf√∏j alt til wrapper
    wrapper.appendChild(navn);          // evt. drop denne hvis du kun vil bruge knappen som navn
    wrapper.appendChild(knapContainer);

    listeEl.appendChild(wrapper);
  });
}

document.getElementById("toggleGrebKnap").addEventListener("click", () => {
  visAlleGreb = !visAlleGreb;

  const knap = document.getElementById("toggleGrebKnap");
  knap.textContent = visAlleGreb ? "üôà Skjul greb" : "üîç Vis alle greb";

  drawSelection();
});

  window.fortrydSidste = function () {
    valgtRute.pop();
    drawSelection();
  };

  window.rydValg = function () {
    valgtRute = [];
    drawSelection();
  };
  
canvas = document.getElementById("canvas");
// === Klik p√• greb for at tilf√∏je ===
canvas.addEventListener("click", function (e) {
  if (!allPredictions.length) return;

  const rect = canvas.getBoundingClientRect();
  const clickX = ((e.clientX - rect.left) * (canvas.width / rect.width) - offsetX) / zoom;
  const clickY = ((e.clientY - rect.top) * (canvas.height / rect.height) - offsetY) / zoom;

  const clicked = allPredictions.find(p => {
    const { x, y, width, height } = p;
    return (
      clickX >= x - width / 2 &&
      clickX <= x + width / 2 &&
      clickY >= y - height / 2 &&
      clickY <= y + height / 2
    );
  });

const aktivtBilledeId = document.getElementById("billedeIdValg").value;
const currentImageName = baseNavn ? `${baseNavn}.webp` : null;

const match = clicked
  ? gemteRuter
      .filter(rute =>
        rute.billede_id === aktivtBilledeId &&
        rute.aktiv === true &&
        (!currentImageName || rute.billedenavn === currentImageName)
      )
      .find(rute =>
        rute.greb?.some(g =>
          Math.abs(g.x - clicked.x) < 5 &&
          Math.abs(g.y - clicked.y) < 5 &&
          g.class === clicked.class
        )
      )
  : null;


  if (match) {
    visRute(match);
  } else if (clicked) {
    valgtRute.push(clicked);
    drawSelection();
  } else if (redigeretRuteId && valgtRute.length === 0) {
    // Kun nulstil hvis du var i gang med at redigere og ingen greb er valgt
    redigeretRuteId = null;
    document.getElementById("gemKnap").dataset.redigerId = "";
    document.getElementById("rutenavn").value = "";
    document.getElementById("rutefarve").value = "";
    document.getElementById("rutegrad").value = "";
    document.getElementById("rutebygger").value = "";
    document.getElementById("ruteAktiv").checked = true;
    valgtRute = [];
    drawSelection();
    alert("‚úèÔ∏è Redigering annulleret.");
  }
});

// === H√∏jreklik for at fjerne greb ===
canvas.addEventListener("contextmenu", function (e) {
  e.preventDefault();

  const rect = canvas.getBoundingClientRect();
  const canvasX = (e.clientX - rect.left) * (canvas.width / rect.width);
  const canvasY = (e.clientY - rect.top) * (canvas.height / rect.height);
  const clickX = (canvasX - offsetX) / zoom;
  const clickY = (canvasY - offsetY) / zoom;

  // Find det valgte greb (bagl√¶ns = topmost f√∏rst)
  for (let i = valgtRute.length - 1; i >= 0; i--) {
    const greb = valgtRute[i];

    if (greb.points && greb.points.length >= 3) {
      // Polygon-mode
      const polygon = greb.points.map(p => Array.isArray(p) ? p : [p.x, p.y]);
      if (pointInPolygon(clickX, clickY, polygon)) {
        valgtRute.splice(i, 1);
        drawSelection();
        return;
      }
    } else {
      // Backup til bbox
      const { x, y, width, height } = greb;
      if (
        clickX >= x - width / 2 &&
        clickX <= x + width / 2 &&
        clickY >= y - height / 2 &&
        clickY <= y + height / 2
      ) {
        valgtRute.splice(i, 1);
        drawSelection();
        return;
      }
    }
  }
});

// === Event listeners ===
document.getElementById("billedeIdValg")?.addEventListener("change", opdaterRuteListe);

document.getElementById("eksisterendeBilleder")?.addEventListener("change", () => {
  const valgtFil = document.getElementById("eksisterendeBilleder").value;
  const defaultSektor = valgtFil.split("_")[0]; // fx "sektor-a"
  const sektorSelect = document.getElementById("billedeIdValg");

  // Finder automatisk sektoren
  if (defaultSektor) {
  sektorSelect.value = defaultSektor;
  }
  
  opdaterRuteListe();
  opdaterOverskrift();
});

document.getElementById("deaktiverAlleKnap").addEventListener("click", async () => {
  const billedeId = document.getElementById("billedeIdValg").value;
  if (!billedeId) return alert("V√¶lg billede f√∏rst.");

  const input = prompt("‚ö†Ô∏è Bekr√¶ft handlingen:\n\nSkriv 'g√∏r inaktiv' for at deaktivere ALLE ruter for denne v√¶g.");
  if (input !== "g√∏r inaktiv") {
    alert("‚ùå Handling afbrudt ‚Äì teksten matchede ikke.");
    return;
  }

  const { error } = await client
    .from("ruter")
    .update({ aktiv: false })
    .eq("billede_id", billedeId);

  if (error) {
    console.error("‚ùå Kunne ikke deaktivere ruter:", error);
    alert("Fejl ved deaktivering.");
  } else {
    alert("üö´ Alle ruter for dette billede er sat som inaktive.");
    await hentRuter();
    drawSelection();
  }
});

document.getElementById("visAlleRuterKnap").addEventListener("click", () => {
  const billedeId = document.getElementById("billedeIdValg").value;
  if (!billedeId) return alert("V√¶lg en v√¶g/sektor f√∏rst.");

  const ruter = gemteRuter.filter(r => r.billede_id === billedeId && r.aktiv);

  if (ruter.length === 0) {
    return alert("Ingen aktive ruter fundet for denne v√¶g.");
  }

  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.save();
  ctx.translate(offsetX, offsetY);
  ctx.scale(zoom, zoom);
  ctx.drawImage(img, 0, 0);

  ruter.forEach(r => {
    const farve = r.farve || "cyan";
    r.greb.forEach(p => drawSingleHold(p, farve));
  });

  ctx.restore();
});

// üîç Zoom med mus (scroll)
canvas.addEventListener("wheel", (e) => {
  e.preventDefault();
  const zoomFactor = 1.1;
  zoom *= e.deltaY < 0 ? zoomFactor : 1 / zoomFactor;
  drawSelection();
});

// üñ±Ô∏è Pan med mus
canvas.addEventListener("mousedown", (e) => {
  isDragging = true;
  dragStart = { x: e.offsetX, y: e.offsetY };
  e.preventDefault(); // üõë Stop scroll
});

canvas.addEventListener("mousemove", (e) => {
  if (isDragging) {
    const dx = e.offsetX - dragStart.x;
    const dy = e.offsetY - dragStart.y;

    const panSpeed = 1.5;
    offsetX += dx * panSpeed;
    offsetY += dy * panSpeed;

    dragStart = { x: e.offsetX, y: e.offsetY };
    drawSelection();
    e.preventDefault();
  }
});

canvas.addEventListener("mouseup", () => (isDragging = false));
canvas.addEventListener("mouseleave", () => (isDragging = false));

// üì± Touch: pan & pinch
canvas.addEventListener("touchstart", (e) => {
  if (e.touches.length === 1) {
    const rect = canvas.getBoundingClientRect();
    dragStart = {
      x: e.touches[0].clientX - rect.left,
      y: e.touches[0].clientY - rect.top
    };
    isDragging = true;
  }

  // üõë Forhindr browserens scroll og zoom
  e.preventDefault();
}, { passive: false });

canvas.addEventListener("touchmove", (e) => {
  if (isDragging && e.touches.length === 1) {
    const rect = canvas.getBoundingClientRect();

    const x = e.touches[0].clientX - rect.left;
    const y = e.touches[0].clientY - rect.top;

    const dx = x - dragStart.x;
    const dy = y - dragStart.y;

    const panSpeed = 1.5;
    offsetX += dx * panSpeed;
    offsetY += dy * panSpeed;

    dragStart = { x, y };
    drawSelection();
  }

  // üõë Forhindr scrolling af hele siden
  e.preventDefault();
}, { passive: false });

document.getElementById("nulstilZoomKnap")?.addEventListener("click", () => {
  zoom = 1;
  offsetX = 0;
  offsetY = 0;
  drawSelection();
});


</script>

<!-- Navne foreslag generator -->
<script>
const farveOrd = {
  gr√∏n: [
    "Skov", "Gift", "Gr√¶s", "Jungle", "Mos", "L√∏v", "Alge", "Slange", "Smaragd",
    "Trolddom", "Ork", "Sk√¶l", "Bambus", "Skovhugger", "Urkraft", "Tr√¶top", "Gro", "Paddehat", "Plante", "V√¶kst"
  ],
  bl√•: [
    "Is", "Himmel", "B√∏lge", "Frost", "Storm", "Hval", "Ocean", "Laser", "Dr√•be",
    "Frossen sj√¶l", "Rums√∏", "Avatar", "Jazz", "Cyber", "Skyline", "Blues", "Torden", "Deep Space", "S√∏mand", "Rovfugl"
  ],
  r√∏d: [
    "Ild", "Blod", "Flamme", "Lava", "Solnedgang", "Krise", "Inferno", "Vulkan", "Hjerte",
    "K√¶rlighed", "Dj√¶vel", "Sabot√∏r", "Drama", "Scarlet", "Lyn", "Salsa", "Krig", "Alarm", "R√∏d zone", "Kirseb√¶r"
  ],
  gul: [
    "Sol", "Banan", "Guld", "Lys", "St√∏v", "Majs", "Tiger√∏je", "Flare", "Komet",
    "Gl√∏d", "Jazzh√•nd", "Citron", "Blixt", "Honning", "Champagne", "B√•l", "Desert", "Solsikke", "B√∏lgel√¶ngde", "Radioaktiv"
  ],
  sort: [
    "Skygge", "Nat", "R√∏g", "Kul", "Sort hul", "M√∏rke", "Batman", "Aske", "Edderkop",
    "Goth", "D√¶mon", "Bl√¶k", "Ravnemark", "S√∏vn", "Skyggej√¶ger", "Dystopi", "Blindhed", "Sort sol", "Morder", "Korp"
  ],
  lilla: [
    "Mystik", "Trylleri", "B√¶r", "T√•ge", "Amethyst", "Magi", "Eliksir", "Fe", "Heks",
    "Galaxy", "Hypnose", "Psyke", "Lavendel", "Karma", "Jazznattens t√•ge", "Druer", "Violet", "Dr√∏m", "Skumring", "Spirit"
  ],
  pink: [
    "Candy", "Slik", "L√¶bestift", "Enhj√∏rning", "Ballade", "K-pop", "Glitter", "Cheerleader", "Barbie",
    "Hjerteknuser", "Disco", "Punkprinsesse", "Popstar", "Diva", "Konfetti", "Glimmer", "Bubblegum", "Fashion", "Flash", "Elektrisk k√¶rlighed"
  ],
  mint: [
    "Menthol", "Frisk", "Frost", "Slik", "Blade", "Krystal", "Mojito", "Wintermute", "Breeze",
    "Matrix", "Neonblad", "Glas", "Cool Shot", "Icebyte", "Nanobot", "K√∏ler", "Cybermint", "Polar", "Techflora", "Freshline"
  ],
  hvid: [
    "Sky", "Snedrive", "Kridt", "Sp√∏gelse", "Snefnug", "Skytsengel", "Blitz", "St√∏vfnug", "Gensk√¶r",
    "Skywalker", "Snehvid", "Stille", "Ghost Mode", "Tavshed", "Dagslys", "Flok", "T√•ge", "Nordlys", "Evighed", "Sneugle"
  ],
  orange: [
    "Flamme", "Morgen", "Gulerod", "Tiger", "Raket", "Solspr√∏jt", "Mamba", "Magma", "Solkriger",
    "Zappy", "Fakkel", "Marmelade", "Krydderi", "Br√¶nding", "H√∏st", "Vulkan", "Zest", "Sonic Boom", "Antares", "Brandalarm"
  ],
  gr√•: [
  "Sten", "T√•ge", "Aske", "St√∏v", "Granit", "Sk√¶rv", "St√•l", "Metal", "Skygge",
  "Beton", "Bro", "S√∏lv", "Dis", "Maskine", "T√•rn", "Gletsjer", "Bymur", "Rust", "Tung luft", "Smedejern"
  ]

};

function overs√¶tGradTilSv√¶rhed(grad) {
  const g = grad.toLowerCase();
  if (["4", "4a", "4b", "4c", "5", "5a"].includes(g)) return "let";
  if (["5b", "5c", "6a", "6a+"].includes(g)) return "middel";
  if (["6b", "6b+", "6c", "6c+"].includes(g)) return "h√•rd";
  return "ekstrem"; // fx 7a og op
}

const overs√¶tFarve = {
  grey: "gr√•", red: "r√∏d", green: "gr√∏n", blue: "bl√•", orange: "orange",
  purple: "lilla", black: "sort", yellow: "gul", white: "hvid",
  pink: "pink", mint: "mint"
};

const sv√¶rhedsEndelse = {
  let: [
    "eventyr", "vej", "dans", "sti", "leg", "fl√∏jlstur", "skridt", "hyggetur", "sving", "loop",
    "smutvej", "hop", "trille", "morgenstr√¶k", "zenrejse", "flyvetur", "b√∏rnesjov", "dugdr√•be", "fjeder", "kattepote"
  ],
  middel: [
    "rejse", "test", "bane", "mission", "tr√¶k", "stigning", "sl√∏jfe", "klatreplan", "kurs", "taktik",
    "svej", "kampbane", "zone", "udfordring", "serie", "indsats", "kontrol", "grebstime", "m√∏nster", "pulsstigning"
  ],
  h√•rd: [
    "kamp", "duel", "knuser", "krig", "h√•n", "strafrunde", "sveddryp", "konflikt", "mur", "kn√¶kpunkt",
    "opg√∏r", "slag", "blokade", "smertepunkt", "v√¶g", "dom", "testamente", "force", "monsterbane", "trykm√•ler"
  ],
  ekstrem: [
    "mareridt", "katastrofe", "underverden", "afgrund", "slagtning", "dommedag", "desperation", "eksplosion", "d√∏dsspring", "hjernevrid",
    "smertedyk", "helvede", "kaos", "nulpunkt", "total nedlukning", "gr√¶demur", "sj√¶levandring", "mentaltest", "apokalypse", "bensplint"
  ]
};

const actionOrd = [
  "Tryk", "Flugt", "Eksplosion", "Snit", "Slam", "Opstigning", "Overtag", "Hvirvel",
  "Spring", "Ryk", "Power", "Chok", "Styrt", "Lyn", "Fald", "Klatre", "Dyk", "Greb",
  "Impact", "Zoom", "Snap", "Skift", "Vrid", "Glid", "Panik"
];

function genererRutenavn(farve, grad) {
  const danskFarve = overs√¶tFarve[farve.toLowerCase()] || "gr√∏n";
  const farveListe = farveOrd[danskFarve] || ["Skygge"];
  const sv√¶rhed = overs√¶tGradTilSv√¶rhed(grad);
  const sv√¶rhedsListe = sv√¶rhedsEndelse[sv√¶rhed] || [];

  const type = Math.random(); // bruges til at afg√∏re typen

  if (type < 0.25) {
    // üîπ 25% chance: kun farveord
    return farveListe[Math.floor(Math.random() * farveListe.length)];
  } else if (type < 0.45) {
    // üî∏ 20% chance: kun actionord
    return actionOrd[Math.floor(Math.random() * actionOrd.length)];
  } else {
    // ‚öôÔ∏è 55% chance: farveord + sv√¶rhedsord
    const ord1 = farveListe[Math.floor(Math.random() * farveListe.length)];
    const ord2 = sv√¶rhedsListe[Math.floor(Math.random() * sv√¶rhedsListe.length)];
    return `${ord1} ${ord2}`;
  }
}



document.getElementById("foresl√•-navn").addEventListener("click", () => {
  const farve = document.getElementById("rutefarve")?.value || "gr√∏n";
  const grad = document.getElementById("rutegrad")?.value || "6a";
  const container = document.getElementById("navneforslag");

  container.innerHTML = ""; // ryd gamle forslag
  container.classList.remove("hidden");

  const forslag = new Set();
  while (forslag.size < 3) {
    forslag.add(genererRutenavn(farve, grad));
  }

  forslag.forEach(navn => {
    const btn = document.createElement("button");
    btn.textContent = navn;
    btn.addEventListener("click", () => {
      document.getElementById("rutenavn").value = navn;
      container.classList.add("hidden");
    });
    container.appendChild(btn);
  });
});



</script>


</body>
</html>
