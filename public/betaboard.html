<!doctype html>
<html lang="da">
<head>
  <meta charset="utf-8" />
  <title>Beta Board</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="css/base.css" /> 
  <link rel="stylesheet" href="css/menu.css" />
  <link rel="stylesheet" href="css/betaboard.css" />
</head>
<body>
  <main>
    <h1>Beta Board</h1>

    <section id="profile">
      <div><strong>Titel:</strong> <span id="title">‚Ä¶</span></div>
      <div><strong>Level:</strong> <span id="level">‚Ä¶</span></div>
      <div class="xp-bar"><div class="xp-fill" id="xpFill"></div></div>
      <div><small>XP: <span id="xp">0</span> / <span id="nextXp">100</span></small></div>
</div>
    </section>

    <h2>Dagens quests</h2>
    <div id="daily"></div>

    <h2>Ugens challenges</h2>
    <div id="weekly"></div>
	
	<h2>BONUS quests</h2>
    <div id="bonus"></div>
	
  </main>

<!-- Text Modal -->
<dialog id="textModal" class="beta-dialog" aria-labelledby="textModalTitle">
  <form method="dialog" id="textForm">
    <h3 id="textModalTitle">Skriv dit svar</h3>

    <div class="card">
      <p id="textPrompt" style="margin:0 0 .5rem 0;"></p>
      <textarea id="textInput" rows="5" placeholder="Skriv her‚Ä¶" style="width:100%;"></textarea>
      <p id="textError" style="color:#b00;display:none;margin:.5rem 0 0 0;"></p>
    </div>

    <div class="modal-actions">
      <div class="counts"><small id="textHelp"></small></div>
      <div class="mini-gap">
        <button type="button" class="btn" id="textCancel">Annull√©r</button>
        <button type="submit" class="btn" id="textSubmit">Bekr√¶ft</button>
      </div>
    </div>
  </form>
</dialog>

<!-- Rute Modal -->
<dialog id="routeModal" class="beta-dialog" aria-labelledby="routeModalTitle">
  <form method="dialog" id="routeForm">
    <h3 id="routeModalTitle">V√¶lg 5 bouldere</h3>

    <div class="modal-grid">
      <!-- Venstre: s√∏g + liste -->
      <div>
        <input id="routeSearch" class="route-search" placeholder="S√∏g navn/grad‚Ä¶" />
        <div id="routeList" class="route-list"></div>
      </div>

      <!-- H√∏jre: preview -->
      <div>
        <div id="previewWrap" class="preview-wrap">
          <canvas id="previewCanvas" style="display:block;width:100%;height:auto;pointer-events:none;"></canvas>
        </div>
        <div id="previewMeta" class="preview-meta"></div>
      </div>
    </div>

    <div class="modal-actions">
      <div class="counts">
        <small>Valgt: <span id="selectedCount">0</span>/<span id="requiredCount">5</span></small>
      </div>
      <div class="mini-gap">
        <button type="button" id="routeCancel" class="btn">Annull√©r</button>
        <button type="submit" class="btn" id="routeSubmit" disabled>Bekr√¶ft</button>
      </div>
    </div>

    <p id="routeError" style="color:#b00;display:none;"></p>
  </form>
</dialog>
<!-- Video Modal -->
<dialog id="videoModal" class="beta-dialog" aria-labelledby="videoModalTitle">
  <form method="dialog" id="videoForm">
    <h3 id="videoModalTitle">Bekr√¶ft med video</h3>

    <div class="modal-grid">
      <!-- Venstre: kun upload -->
      <div class="card">
        <strong>V√¶lg/optag fra din enhed</strong>
        <p><small>V√¶lg en videofil (anbefalet ‚â• 3 sek.). Videoen uploades ikke.</small></p>
        <input id="videoFileInput" type="file" accept="video/*" capture="user" />
      </div>

      <!-- H√∏jre: preview -->
      <div>
        <div class="preview-wrap">
          <video id="videoPreview" playsinline controls></video>
        </div>
        <div id="videoMeta" class="preview-meta"></div>
      </div>
    </div>

    <div class="modal-actions">
      <div class="counts"><small>V√¶lg en video og tryk Bekr√¶ft</small></div>
      <div class="mini-gap">
        <button type="button" class="btn" id="videoCancel">Annull√©r</button>
        <button type="submit" class="btn" id="videoSubmit" disabled>Bekr√¶ft</button>
      </div>
    </div>
    <p id="videoError" style="color:#b00;display:none;"></p>
  </form>
</dialog>


  <script type="module">
import { client, adgangskontrol, inds√¶tMenu } from './auth.js';


adgangskontrol({
  tilladteRoller: [],
  redirectVedFejl: "index.html",
  efterLogin: bruger => inds√¶tMenu(bruger)
});


// Farver til UI
const COLOR_HEX = { 'gr√∏n':'#2ecc71','gul':'#f1c40f','bl√•':'#3498db','lilla':'#9b59b6','r√∏d':'#e74c3c','sort':'#2c3e50' };
const nice = s => (s||'').charAt(0).toUpperCase() + (s||'').slice(1);
// Hvor dine webp-billeder ligger (tilpas stien til dit projekt!)
const IMAGE_BASE = 'https://cianxaxaphvrutmstydr.supabase.co/storage/v1/object/public/ruter/';   
const IMG_EXT    = '.webp'; 

// cache af billeder
const imageUrlCache = new Map();
const imageElCache = new Map();
// Konverter #RRGGBB -> rgba(r,g,b,a)
function hexToRgba(hex, a=1){
  const h = hex.replace('#','');
  const v = parseInt(h.length===3 ? h.split('').map(c=>c+c).join('') : h, 16);
  const r = (v>>16)&255, g=(v>>8)&255, b=v&255;
  return `rgba(${r},${g},${b},${a})`;
}
// preview animation handle
let previewAnimId = null;
let currentPreviewRouteId = null;
let previewWcss = null;
let completedSet = new Set();

// --- Collapsible quest groups ---
const groupMeta = new Map(); // containerId -> {detailsEl, summaryEl, titleEl, rightEl}

function ensureGroupDetails(containerId, label){
  if (groupMeta.has(containerId)) return groupMeta.get(containerId);

  const listEl = document.getElementById(containerId);
  if (!listEl) return null;

  // H2 forventes at st√• lige f√∏r container-div'en
  const h2 = listEl.previousElementSibling && listEl.previousElementSibling.tagName === 'H2'
    ? listEl.previousElementSibling
    : null;

  // Opret <details> + <summary>
  const details = document.createElement('details');
  details.className = 'quest-group';

  const summary = document.createElement('summary');
  summary.className = 'quest-group-summary';

  const titleSpan = document.createElement('span');
  titleSpan.className = 'sum-title';
  titleSpan.textContent = label;

  const rightSpan = document.createElement('span');
  rightSpan.className = 'sum-right';
  rightSpan.textContent = ''; // udfyldes ved render

  summary.appendChild(titleSpan);
  summary.appendChild(rightSpan);
  details.appendChild(summary);

  // Flyt containeren ind i details
  listEl.parentNode.insertBefore(details, h2 || listEl);
  details.appendChild(listEl);

  // Fjern den gamle H2, hvis den findes
  if (h2) h2.remove();

  const meta = { detailsEl: details, summaryEl: summary, titleEl: titleSpan, rightEl: rightSpan };
  groupMeta.set(containerId, meta);
  return meta;
}

// S√¶t badge-tekst og fold/√•bn automatisk
function updateGroupHeader(containerId, label, remainingCount){
  const meta = ensureGroupDetails(containerId, label);
  if (!meta) return;
  meta.titleEl.textContent = label;
  meta.rightEl.textContent = remainingCount > 0 ? `${remainingCount} tilbage` : 'Alle fuldf√∏rt üéâ';
  // Fold hvis intet tilbage ‚Äì √•bn hvis der er noget
  meta.detailsEl.open = remainingCount > 0;
}


function stopPreviewAnim(){
 if (previewAnimId) cancelAnimationFrame(previewAnimId); previewAnimId = null; }

// Hash af f√∏rste 64KB (fingeraftryk ‚Äì ingen upload)
async function blobFingerprint(blob) {
  const slice = await blob.slice(0, 65536).arrayBuffer();
  const hashBuf = await crypto.subtle.digest('SHA-256', slice);
  const hashArr = Array.from(new Uint8Array(hashBuf));
  return hashArr.map(b => b.toString(16).padStart(2,'0')).join('');
}

// L√¶s videol√¶ngde (sek.) uden at uploade
async function getVideoDuration(blob) {
  return new Promise((resolve, reject) => {
    const url = URL.createObjectURL(blob);
    const v = document.createElement('video');
    v.preload = 'metadata';
    v.src = url;
    v.onloadedmetadata = () => { URL.revokeObjectURL(url); resolve(v.duration || 0); };
    v.onerror = () => { URL.revokeObjectURL(url); reject(new Error('Kunne ikke l√¶se videometadata')); };
  });
}

// Sikkert kilde-skift, s√• vi undg√•r ‚Äúabort‚Äù-st√∏j
function safeSetVideoFile(videoEl, blobUrl) {
  try { videoEl.pause(); } catch {}
  if (videoEl.srcObject) videoEl.srcObject = null;
  if (videoEl.src) { try { URL.revokeObjectURL(videoEl.src); } catch {} }
  videoEl.removeAttribute('src');
  videoEl.load();
  videoEl.src = blobUrl;
  videoEl.play().catch(()=>{});
}

function decodeImage(url){
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.onload = () => resolve(img);
    img.onerror = reject;
    img.src = url;
  });
}

async function loadSectorImage(billede_id) {
  if (!billede_id) throw new Error('billede_id mangler');

  // return√©r eksisterende promise hvis vi allerede loader/har det
  let promise = imageElCache.get(billede_id);
  if (!promise) {
    promise = (async () => {
      const url = await getImageUrlFor(billede_id);
      const img = await decodeImage(url);
      return { img, url };
    })();
    imageElCache.set(billede_id, promise);
  }
  return promise;
}


async function getImageUrlFor(billede_id) {
  if (!billede_id) throw new Error('billede_id mangler');
  if (imageUrlCache.has(billede_id)) return imageUrlCache.get(billede_id); 

  const storage = client.storage.from('ruter');
  const { data: files, error } = await storage.list('', {
    limit: 1000,
    sortBy: { column: 'updated_at', order: 'desc' },
    search: `${billede_id}_`
  });
  if (error) throw error;

  const re = new RegExp(`^${billede_id}_(\\d{4}-\\d{2}-\\d{2})\\.webp$`, 'i');
  const matches = (files || []).filter(f => re.test(f.name));
  if (!matches.length) throw new Error(`Ingen matchende .webp for ${billede_id}`);

  // v√¶lg nyeste efter dato i navnet
  matches.sort((a, b) => {
    const da = new Date(a.name.match(re)[1]);
    const db = new Date(b.name.match(re)[1]);
    return db - da;
  });

  const latestName = matches[0].name;
  const { data: pub } = storage.getPublicUrl(latestName);
  const url = pub.publicUrl;
  imageUrlCache.set(billede_id, url);
  return url;
}

// Hent ruter i valgfri farve
async function fetchRuterByColor(color) {
  const { data, error } = await client.rpc('ruter_by_color', { p_color: color });
  if (error) { console.error(error); return []; }
  return data || [];
}

// Tegn 'greb' oven p√• canvas
function drawGreb(canvas, imgEl, greb) {
  const ctx = canvas.getContext('2d');
  const w = canvas.width  = imgEl.clientWidth;
  const h = canvas.height = imgEl.clientHeight;
  ctx.clearRect(0,0,w,h);
  if (!greb) return;

  const drawCircle = (x,y,r=8) => { ctx.beginPath(); ctx.arc(x,y,r,0,Math.PI*2); ctx.fill(); };
  const drawLine = (pts) => { if (pts.length<2) return; ctx.beginPath(); ctx.moveTo(pts[0].x, pts[0].y); for (let i=1;i<pts.length;i++) ctx.lineTo(pts[i].x, pts[i].y); ctx.stroke(); };
  const drawPoly = (pts) => { if (pts.length<3) return; ctx.beginPath(); ctx.moveTo(pts[0].x, pts[0].y); for (let i=1;i<pts.length;i++) ctx.lineTo(pts[i].x, pts[i].y); ctx.closePath(); ctx.stroke(); };

  // farve & stil
  ctx.fillStyle   = 'rgba(52, 152, 219, 0.85)'; // bl√• fyld
  ctx.strokeStyle = 'rgba(44, 62, 80, 0.9)';    // m√∏rk kant
  ctx.lineWidth   = 3;

  // Hj√¶lper til at konvertere normaliserede coords -> pixels
  const toPx = (x,y) => {
    // hvis v√¶rdierne ser normaliserede ud (0..1), skaler til pixels
    const isNorm = x>=0 && x<=1 && y>=0 && y<=1;
    return isNorm ? { x: x*w, y: y*h } : { x, y };
  };

  // Underst√∏t almindelige formater
  try {
    if (Array.isArray(greb)) {
      greb.forEach(g => {
        if (g.type === 'line' && Array.isArray(g.points)) {
          const pts = g.points.map(p => toPx(p.x, p.y));
          drawLine(pts);
        } else if (g.type === 'polygon' && Array.isArray(g.points)) {
          const pts = g.points.map(p => toPx(p.x, p.y));
          drawPoly(pts);
        } else if (g.type === 'circle' && g.x != null && g.y != null) {
          const p = toPx(g.x, g.y); drawCircle(p.x, p.y, g.r || 10);
        } else if (g.x != null && g.y != null) {
          const p = toPx(g.x, g.y); drawCircle(p.x, p.y, g.r || 8);
        }
      });
    } else if (greb.points) {
      const pts = greb.points.map(p => toPx(p.x, p.y));
      (greb.type === 'polygon') ? drawPoly(pts) : drawLine(pts);
    }
  } catch(e) {
    console.warn('Kunne ikke tegne greb:', e);
  }
}

// √Öbn video-proof modal og return√©r { ok: true, meta } n√•r brugeren bekr√¶fter
function openVideoProof({ minSeconds = 3, maxSizeMB = 200 } = {}) {
  const dlg      = document.getElementById('videoModal');
  const form     = document.getElementById('videoForm');
  const fileInput= document.getElementById('videoFileInput');
  const videoEl  = document.getElementById('videoPreview');
  const metaEl   = document.getElementById('videoMeta');
  const errEl    = document.getElementById('videoError');
  const submit   = document.getElementById('videoSubmit');
  const cancel   = document.getElementById('videoCancel');

  let chosenBlob = null;

  let resolveFn, rejectFn;
  const p = new Promise((res, rej) => { resolveFn = res; rejectFn = rej; });

  const resetPreview = () => {
    if (videoEl.src) { try { URL.revokeObjectURL(videoEl.src); } catch {} }
    videoEl.removeAttribute('src'); videoEl.load();
    metaEl.textContent = ''; errEl.style.display = 'none';
    submit.disabled = true; chosenBlob = null;
  };

  async function useBlob(blob, label='Valgt video') {
    try {
      const sizeMB = blob.size / (1024*1024);
      if (sizeMB > maxSizeMB) throw new Error(`Videoen er for stor (${sizeMB.toFixed(1)} MB > ${maxSizeMB} MB).`);
      const dur = await getVideoDuration(blob);
      if (dur < minSeconds) throw new Error(`Videoen er for kort (${dur.toFixed(1)}s < ${minSeconds}s).`);

      const url = URL.createObjectURL(blob);
      safeSetVideoFile(videoEl, url);

      metaEl.textContent = `${label} ‚Ä¢ Varighed ${dur.toFixed(1)}s ‚Ä¢ ${sizeMB.toFixed(1)} MB`;
      chosenBlob = blob;
      submit.disabled = false;
      errEl.style.display = 'none';
    } catch(e) {
      resetPreview();
      errEl.textContent = e.message || 'Ugyldig videofil';
      errEl.style.display = 'block';
    }
  }

  async function onFile() {
    if (!fileInput?.files?.length) return;
    await useBlob(fileInput.files[0], 'Valgt video');
  }

  function onEscCancel(e) { e.preventDefault(); onCancel(); }
  function onCancel(){
    cleanup(); dlg.close();
    if (typeof rejectFn === 'function') rejectFn(new Error('cancelled'));
  }

  async function onSubmit(e){
    e.preventDefault();
    if (!chosenBlob) {
      errEl.textContent = 'V√¶lg en video f√∏rst.'; errEl.style.display = 'block';
      return;
    }
    try {
      const [sha256, dur] = await Promise.all([
        blobFingerprint(chosenBlob),
        getVideoDuration(chosenBlob)
      ]);
      const meta = {
        mime: chosenBlob.type || 'video/mp4',
        size_bytes: chosenBlob.size,
        duration_s: +dur.toFixed(2),
        sha256_first64kb: sha256
      };
      cleanup(); dlg.close();
      if (typeof resolveFn === 'function') resolveFn({ ok: true, meta });
    } catch(err) {
      errEl.textContent = err.message || 'Kunne ikke validere video'; errEl.style.display = 'block';
    }
  }

  function cleanup(){
    resetPreview();
    if (fileInput) {
      fileInput.value = '';
      fileInput.removeEventListener('change', onFile);
    }
    form.removeEventListener('submit', onSubmit);
    cancel.removeEventListener('click', onCancel);
    dlg.removeEventListener('cancel', onEscCancel);
  }

  // init & show
  resetPreview();
  if (fileInput) fileInput.addEventListener('change', onFile);
  form.addEventListener('submit', onSubmit);
  cancel.addEventListener('click', onCancel);
  dlg.addEventListener('cancel', onEscCancel);

  dlg.showModal();
  return p;
}
// √Öbn tekst-proof modal: tjek for kr√¶vede n√∏gleord (case-insensitive, accent-insensitive)
function openTextProof({
  prompt = "Skriv dit svar:",
  keywords = [],           // fx ["crimps","slopers","jugs","underclings"]
  min_matches = null       // fx 4 (hvis null => alle keywords kr√¶ves)
} = {}) {
  const dlg   = document.getElementById('textModal');
  const form  = document.getElementById('textForm');
  const area  = document.getElementById('textInput');
  const lab   = document.getElementById('textPrompt');
  const errEl = document.getElementById('textError');
  const help  = document.getElementById('textHelp');
  const cancel= document.getElementById('textCancel');

  const need = Math.max(0, Number(min_matches ?? keywords.length));
  lab.textContent = prompt || "Skriv dit svar:";
	help.textContent = keywords.length
  ? `Kr√¶vede n√∏gleord: 0/${need}`
  : "";

  area.value = "";
  errEl.style.display = 'none';

  let resolveFn, rejectFn;
  const p = new Promise((res, rej) => { resolveFn = res; rejectFn = rej; });

  function normalize(s) {
    return (s||"")
      .toLowerCase()
      .normalize("NFD").replace(/\p{Diacritic}+/gu, ""); // strip accents
  }

function validate(text) {
  // normaliser input
  const norm = s => (s||"")
    .toLowerCase()
    .normalize("NFD").replace(/\p{Diacritic}+/gu, "");

  const t = norm(text);

  const hits = [];
  const missing = [];

  for (const kwRaw of (keywords || [])) {
    const kw = norm(kwRaw).trim();
    if (!kw) continue;

    // byg simple varianter: singular/plural (fjern/tilf√∏j s)
    const variants = new Set([kw]);
    if (kw.endsWith("s")) variants.add(kw.slice(0, -1));   // "slopers" -> "sloper"
    else variants.add(kw + "s");                           // "undercling" -> "underclings"

    // ordgr√¶nse‚Äëmatch for at undg√• fx "slopersville"
    // hvis browser ikke underst√∏tter \b p√• ikke-latinske, er det stadig OK her
    let matched = false;
    for (const v of variants) {
      // tillad komma/punktum osv. omkring ordet
      const re = new RegExp(`(^|[^a-z])${v}([^a-z]|$)`, "i");
      if (re.test(t)) { matched = true; break; }
    }

    if (matched) hits.push(kwRaw);
    else missing.push(kwRaw);
  }

  // hj√¶lpetekst (live eller ved fejl)
  if (help) help.textContent = `Kr√¶vede n√∏gleord: ${hits.length}/${Math.max(0, Number(min_matches ?? keywords.length))}`;

  return { ok: hits.length >= Math.max(0, Number(min_matches ?? keywords.length)), hits, missing };
}

  function onSubmit(e){
    e.preventDefault();
    const txt = area.value.trim();
    const { ok, hits } = validate(txt);
    if (!ok) {
      errEl.textContent = `Svar mangler n√∏gleord (${hits.length}/${need}).`;
      errEl.style.display = 'block';
      return;
    }
    cleanup(); dlg.close();
    resolveFn({ ok:true, text: txt, matched_keywords: hits });
  }

  function onCancel(){
    cleanup(); dlg.close();
    rejectFn(new Error('cancelled'));
  }

  function onEsc(e){ e.preventDefault(); onCancel(); }

  function cleanup(){
    form.removeEventListener('submit', onSubmit);
    cancel.removeEventListener('click', onCancel);
    dlg.removeEventListener('cancel', onEsc);
  }

  form.addEventListener('submit', onSubmit);
  cancel.addEventListener('click', onCancel);
  dlg.addEventListener('cancel', onEsc);

  dlg.showModal();
  return p;
}

// --- Rotation helpers (deterministisk "tilf√¶ldig") ---
function strHash(s){
  let h = 2166136261 >>> 0;
  for (let i=0;i<s.length;i++){ h ^= s.charCodeAt(i); h = Math.imul(h, 16777619); }
  return h >>> 0;
}
function mulberry32(seed){
  let t = seed >>> 0;
  return function(){
    t += 0x6D2B79F5;
    let r = Math.imul(t ^ (t >>> 15), 1 | t);
    r ^= r + Math.imul(r ^ (r >>> 7), 61 | r);
    return ((r ^ (r >>> 14)) >>> 0) / 4294967296;
  };
}
function pickDeterministic(arr, n, seedStr){
  if (!Array.isArray(arr) || !arr.length || n<=0) return [];
  const rnd = mulberry32(strHash(seedStr));
  const a = arr.slice();
  // Fisher‚ÄìYates med deterministisk rnd
  for (let i = a.length - 1; i > 0; i--) {
    const j = Math.floor(rnd() * (i + 1));
    [a[i], a[j]] = [a[j], a[i]];
  }
  return a.slice(0, Math.min(n, a.length));
}
// Hj√¶lpere til periode-strenge
function dayKey(d=new Date()){
  return d.toISOString().slice(0,10); // YYYY-MM-DD
}
function isoWeekKey(d=new Date()){
  const date = new Date(Date.UTC(d.getFullYear(), d.getMonth(), d.getDate()));
  const dayNum = date.getUTCDay() || 7;
  date.setUTCDate(date.getUTCDate() + 4 - dayNum);
  const yearStart = new Date(Date.UTC(date.getUTCFullYear(),0,1));
  const week = Math.ceil((((date - yearStart) / 86400000) + 1) / 7);
  return `${date.getUTCFullYear()}-W${String(week).padStart(2,'0')}`;
}
// Aktiv-periode filter (active_from/active_to)
function isActiveNow(q, now = new Date()){
  const fromOk = !q.active_from || new Date(q.active_from) <= now;
  const toOk   = !q.active_to   || now <= new Date(q.active_to);
  return (q.is_active !== false) && fromOk && toOk;
}

async function adjustXp(delta) {
  try {
    const { data: { user } } = await client.auth.getUser();
    if (!user) return;

    // s√∏rg for en r√¶kke findes
    await client.from('user_xp').upsert({ user_id: user.id }).select();

    // l√¶s nuv√¶rende XP
    const { data: ux, error: rErr } = await client
      .from('user_xp')
      .select('xp_total')
      .eq('user_id', user.id)
      .single();
    if (rErr) throw rErr;

    const curr = ux?.xp_total ?? 0;
    const next = Math.max(0, curr + delta); // clamp til 0, s√• vi ikke g√•r i minus
    const today = new Date().toISOString().slice(0,10);

    // opdat√©r XP
    const { error: uErr } = await client
      .from('user_xp')
      .update({ xp_total: next, last_activity_date: today })
      .eq('user_id', user.id);
    if (uErr) throw uErr;

    // log event (valgfrit men rart)
    await client.from('user_xp_events').insert({
      user_id: user.id,
      delta_xp: delta,
      reason: 'debug_adjust'
    });

    // opdat√©r UI
    load();
  } catch (e) {
    alert(e.message || 'Kunne ikke justere XP');
  }
}
async function openRoutePicker(requiredCount = 5, color = 'gul') {
  const dlg = document.getElementById('routeModal');
  const form = document.getElementById('routeForm');
  const listEl = document.getElementById('routeList');
  const searchEl = document.getElementById('routeSearch');
  const err = document.getElementById('routeError');
  const cancelBtn = document.getElementById('routeCancel');
  const submitBtn = document.getElementById('routeSubmit');
  const selCountEl = document.getElementById('selectedCount');
  const reqCountEl = document.getElementById('requiredCount');
  const previewCanvas = document.getElementById('previewCanvas');
  const previewMeta   = document.getElementById('previewMeta');

  err.style.display = 'none';
  submitBtn.disabled = true; selCountEl.textContent = '0';
  listEl.innerHTML = 'Indl√¶ser‚Ä¶';
  const clearPreview = () => {
  const ctx = previewCanvas.getContext('2d');
  ctx.clearRect(0,0,previewCanvas.width,previewCanvas.height);
  previewMeta.textContent = '';
};
  
  reqCountEl.textContent = requiredCount;
  form.querySelector('h3').textContent = `V√¶lg ${requiredCount} ${color} ${color==='gul'?'bouldere':'ruter'}`;

  err.style.display = 'none';
  submitBtn.disabled = true; selCountEl.textContent = '0';
  listEl.innerHTML = 'Indl√¶ser‚Ä¶';

  const allRaw = await fetchRuterByColor(color);
  // Hvis vi er i en boulder-quest, filtr√©r til sektor-*
  const isBoulderQuest = true; // s√¶t evt. baseret p√• quest payload senere
  const all = isBoulderQuest ? allRaw.filter(r => (r.billede_id||'').startsWith('sektor-')) : allRaw;

  let filtered = all.slice();
  const selected = new Set();

async function showPreview(route) {
  const canvas = document.getElementById('previewCanvas');
  const ctx    = canvas.getContext('2d');
  const meta   = document.getElementById('previewMeta');
  const wrap   = document.getElementById('previewWrap');

  // undg√• un√∏digt arbejde
  if (currentPreviewRouteId === route?.id) return;
  currentPreviewRouteId = route?.id || null;

  // NULSTIL transform f√∏r ny tegning
  if (typeof ctx.resetTransform === 'function') ctx.resetTransform();
  else ctx.setTransform(1,0,0,1,0,0);
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  meta.textContent = '';

  if (!route) return;

  try {
    const { img } = await loadSectorImage(route.billede_id);

    // üîí M√•l bredde kun f√∏rste gang i denne modal-session
    if (!previewWcss) {
      const { width } = wrap.getBoundingClientRect();
      previewWcss = Math.floor(width); // l√•s til heltal for stabilitet
    }

    const dpr   = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    const wCss  = previewWcss;
    const scale = wCss / img.naturalWidth;
    const hCss  = Math.max(1, Math.round(img.naturalHeight * scale));

    // Pixelbuffer + DPR (crisp), men CSS-st√∏rrelse stabil
    canvas.width  = Math.round(wCss * dpr);
    canvas.height = Math.round(hCss * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

    canvas.style.width  = wCss + 'px';
    canvas.style.height = hCss + 'px';

    // Hj√¶lpere: skaler punkter (b√•de normaliserede 0..1 og pixel)
    const toPx = (x, y) => {
      const norm = (x>=0 && x<=1 && y>=0 && y<=1);
      return {
        x: norm ? x * wCss : x * scale,
        y: norm ? y * hCss : y * scale
      };
    };

    // Byg Path2D √©n gang (hurtigt at genbruge)
    const paths = (route.greb || []).map(p => {
      const path = new Path2D();
      if (Array.isArray(p.points) && p.points.length >= 2) {
        const p0 = toPx(p.points[0].x, p.points[0].y);
        path.moveTo(p0.x, p0.y);
        for (let i=1; i<p.points.length; i++) {
          const pi = toPx(p.points[i].x, p.points[i].y);
          path.lineTo(pi.x, pi.y);
        }
        if (p.points.length >= 3) path.closePath();
      } else if (Number.isFinite(p.x) && Number.isFinite(p.y) && Number.isFinite(p.width) && Number.isFinite(p.height)) {
        // bbox fallback
        const c = toPx(p.x, p.y);
        const w = (p.width  * scale);
        const h = (p.height * scale);
        path.rect(c.x - w/2, c.y - h/2, w, h);
      }
      return path;
    });

    // Farver
    const colorName = (route?.farve || '').toLowerCase();
    const uiColor   = COLOR_HEX[colorName] || COLOR_HEX['gul'];
    const fillCol   = hexToRgba(uiColor, 0.20);
    const strokeCol = hexToRgba(uiColor, 1.00);

    // --- TEGN √âN GANG (ingen RAF) ---
    // baggrund
    ctx.clearRect(0,0,wCss,hCss);
    ctx.drawImage(img, 0, 0, wCss, hCss);

    ctx.fillStyle = 'rgba(0,0,0,0.5)';
    ctx.fillRect(0,0,wCss,hCss);

    // ‚Äúvinduer‚Äù i m√∏rket = greb
    ctx.save();
    ctx.globalCompositeOperation = 'destination-out';
    paths.forEach(path => ctx.fill(path));
    ctx.restore();

    // gl√∏d (statisk ‚Äì hurtig)
    ctx.save();
    ctx.shadowColor = 'white';
    ctx.shadowBlur  = 12;
    ctx.strokeStyle = 'white';
    ctx.lineWidth   = 3;
    paths.forEach(path => ctx.stroke(path));
    ctx.restore();

    // farvet fyld + kant
    ctx.fillStyle = fillCol;
    paths.forEach(path => ctx.fill(path));
    ctx.strokeStyle = strokeCol;
    ctx.lineWidth   = 1;
    paths.forEach(path => ctx.stroke(path));

    // meta
    meta.textContent = `${route.navn || 'Uden navn'} ‚Ä¢ ${route.grad || ''} ‚Ä¢ ${route.billede_id}`;
  } catch (e) {
    console.warn('Preview fejl:', e);
    meta.textContent = `${route.navn || 'Uden navn'} ‚Ä¢ ${route.grad || ''} ‚Ä¢ (intet billede)`;
  }
}
  function render() {
    listEl.innerHTML = '';
    filtered.forEach(r => {
	const row = document.createElement('label');
	row.className = 'route-item';
	row.tabIndex = 0;
      row.innerHTML = `
        <input type="checkbox" data-id="${r.id}" ${selected.has(r.id)?'checked':''}/>
        <span class="swatch" style="background:${COLOR_HEX[color] || '#ccc'}"></span>
        <div class="txt">
          <div class="title">${r.navn ? r.navn : '(Uden navn)'}</div>
          <small>${nice(color)} ‚Ä¢ ${r.grad || ''} ‚Ä¢ ${r.billede_id || ''}</small>
        </div>
      `;
      const box = row.querySelector('input[type="checkbox"]');
      // hover/klik -> preview
row.addEventListener('click', (e) => {
  if (e.target === box) return;      // lad checkbox selv h√•ndtere
  showPreview(r);                    // <-- vis preview ved tap/klik
  // din toggle-logic:
  box.checked = !box.checked;
  box.dispatchEvent(new Event('change'));
});
box.addEventListener('change', () => {
  showPreview(r); // <-- vigtig for mobil
  if (box.checked) {
    if (selected.size >= requiredCount) {
      box.checked = false; return;
    }
    selected.add(r.id);
  } else {
    selected.delete(r.id);
  }
  selCountEl.textContent = String(selected.size);
  submitBtn.disabled = selected.size !== requiredCount;
});

      listEl.appendChild(row);
    });

    // auto-preview f√∏rste i listen
    if (filtered.length) {
  showPreview(filtered[0]);
} else {
  clearPreview();
  previewMeta.textContent = `Ingen aktive ${color} at v√¶lge lige nu.`;
  submitBtn.disabled = true;
}

  }

  // s√∏g i navn/grad
  searchEl.oninput = () => {
    const q = (searchEl.value || '').toLowerCase();
    filtered = all.filter(r =>
      (r.navn || '').toLowerCase().includes(q) ||
      (r.grad || '').toLowerCase().includes(q) ||
      (r.billede_id || '').toLowerCase().includes(q)
    );
    render();
  };

  render(); dlg.showModal();

return new Promise((resolve, reject) => {
  const onSubmit = (e) => {
    e.preventDefault();
    if (selected.size !== requiredCount) {
      err.textContent = `V√¶lg pr√¶cis ${requiredCount}.`; 
      err.style.display = 'block'; 
      return;
    }
    const ids = Array.from(selected);
    cleanup();
    dlg.close();        // luk modalen
    resolve(ids);       // return√©r valgte ruter
  };

  const onCancel = () => {
    cleanup();
    dlg.close();        // luk modalen
    reject(new Error('cancelled'));
  };

  const onEscCancel = (e) => {
    // Esc sender et "cancel"-event p√• <dialog>. Vi vil ogs√• lave cleanup.
    e.preventDefault(); // undg√• dobbelt lukning
    onCancel();
  };

function cleanup(){
  form.removeEventListener('submit', onSubmit);
  cancelBtn.removeEventListener('click', onCancel);
  dlg.removeEventListener('cancel', onEscCancel);
  searchEl.oninput = null;
  stopPreviewAnim();
  currentPreviewRouteId = null;
  previewWcss = null; 
}

  form.addEventListener('submit', onSubmit);
  cancelBtn.addEventListener('click', onCancel);
  dlg.addEventListener('cancel', onEscCancel); // g√∏r Esc til "Annull√©r"
});
}
function levelFromXp(xp) {
  return Math.max(1, Math.floor((1 + Math.sqrt(1 + 8 * (xp / 100))) / 2));
}
function titleFromXp(xp){
  if (xp < 600) return 'Chalk Rookie';
  if (xp < 1800) return 'Beta Seeker';
  if (xp < 3600) return 'Crux Crusher';
  if (xp < 6000) return 'Send Master';
  return 'Wall Legend';
}
function nextLevelTotalXp(level){
  // total XP to reach next level+1: 100*(L+1)*(L+2)/2
  const L = Math.max(1, level);
  return 100 * (L+1) * (L+2) / 2;
}
function totalXpForLevel(level){
  return 100 * level * (level + 1) / 2;
}
async function load() {
  const { data: { user } } = await client.auth.getUser();
  if (!user) { window.location.href = '/login.html'; return; }

  await client.from('user_xp').upsert({ user_id: user.id }).select();
  const { data: ux } = await client.from('user_xp').select('*').eq('user_id', user.id).single();

  const xp = ux?.xp_total || 0;
  const lvl = levelFromXp(xp);
  const minL = 1, maxL = 4;
  const title = titleFromXp(xp);
  const fitsLevel = q => (q.min_level ?? 1) <= lvl && lvl <= (q.max_level ?? 99);

  document.getElementById('level').textContent = lvl;
  document.getElementById('title').textContent = title;
  document.getElementById('xp').textContent = xp;

function xpToReachLevel(L){           // total XP for at N√Ö level L (1 => 0 XP)
  return 100 * (L - 1) * L / 2;
}
const base = xpToReachLevel(lvl);     // baseline for nuv√¶rende level
const next = xpToReachLevel(lvl + 1); // gr√¶nse til n√¶ste level
const span = next - base;             // XP der kr√¶ves i DETTE level
const within = xp - base;             // hvor meget du har i DETTE level
const pct = Math.max(0, Math.min(100, (within / span) * 100));

document.getElementById('xpFill').style.width = pct + '%';

// Vis ‚Äúinden i level / krav for level‚Äù
document.getElementById('xp').textContent = within;  // fx 80
document.getElementById('nextXp').textContent = span; // fx 100

  // fetch quests
  const { data: daily } = await client
    .from('beta_quests')
    .select('*')
    .eq('type','daily')
    .eq('is_active', true);
	
  const { data: bonus } = await client
    .from('beta_quests')
    .select('*')
    .eq('type','bonus')
    .eq('is_active', true);

  const { data: weekly } = await client
    .from('beta_quests')
    .select('*')
    .eq('type','weekly')
    .eq('is_active', true);

  // Hent completed quest_ids for brugeren
  const { data: completedRows } = await client
    .from('user_quests')
    .select('quest_id')
    .eq('user_id', user.id)
    .eq('status', 'completed');

completedSet = new Set((completedRows || []).map(r => r.quest_id));
  
// filtr√©r p√• level + active window
const now = new Date();
const dailyPool  = (daily  || []).filter(q => fitsLevel(q) && isActiveNow(q, now));
const weeklyPool = (weekly || []).filter(q => fitsLevel(q) && isActiveNow(q, now));
const bonusPool  = (bonus  || []).filter(q => /* valgfrit level-gate */ isActiveNow(q, now));

// deterministisk seed per bruger
const uid = user.id;

// v√¶lg 3 daily (roterer dagligt), 1 weekly (roterer pr. uge), 1 bonus (dagligt)
const dailyPick  = pickDeterministic(dailyPool, 3, `daily:${uid}:${dayKey(now)}`);
const weeklyPick = pickDeterministic(weeklyPool, 1, `weekly:${uid}:${isoWeekKey(now)}`);
const bonusPick  = pickDeterministic(bonusPool, 1, `bonus:${uid}:${dayKey(now)}`);

// render
renderQuests('daily',  dailyPick,  false, completedSet);
renderQuests('weekly', weeklyPick, true,  completedSet);
renderQuests('bonus',  bonusPick,  false, completedSet);

}
function renderQuests(containerId, quests, weekly=false, completedSet=new Set()){
  const labelMap = {
    daily: 'Dagens quests',
    weekly: 'Ugens challenges',
    bonus: 'BONUS quests'
  };
  const label = labelMap[containerId] || 'Quests';

  // S√∏rg for at gruppen er kollapsbar
  ensureGroupDetails(containerId, label);

  const el = document.getElementById(containerId);
  el.innerHTML = '';

  if (!quests || quests.length === 0) {
    el.innerHTML = `<div style="opacity:.7"><small>Ingen ${weekly ? 'ugentlige ' : ''}quests lige nu ‚ú®</small></div>`;
    updateGroupHeader(containerId, label, 0);
    return;
  }

  // Hvor mange mangler?
  const remaining = quests.filter(q => !completedSet.has(q.id)).length;

  quests.forEach(q=>{
    const done = completedSet.has(q.id);
    const card = document.createElement('div');
    card.className = 'card';
    card.innerHTML = `
      <div><strong>${q.name}</strong> (${q.xp_reward} XP)</div>
      <div><small>${q.description || ''}</small></div>
      <div style="margin-top:8px;">
        <button class="btn" data-id="${q.id}" ${done ? 'disabled' : ''}>
          ${done ? 'Allerede fuldf√∏rt' : 'Mark√©r som fuldf√∏rt'}
        </button>
      </div>
    `;
    const btn = card.querySelector('button');

    if (!done) {
      btn.addEventListener('click', async () => {
        if (btn.dataset.busy) return;
        btn.dataset.busy = "1";
        const prevText = btn.textContent;
        btn.textContent = 'Behandler‚Ä¶';
        btn.disabled = true;

        const ok = await completeQuest(q, btn);
        if (!ok) { // annulleret/fejl -> rulle tilbage
          btn.disabled = false;
          btn.textContent = prevText;
        } else {
          // Ved success bliver den disablet i completeQuest og load() re-render
        }
        delete btn.dataset.busy;
      });
    }

    el.appendChild(card);
  });

  updateGroupHeader(containerId, label, remaining);
}

async function completeQuest(q, btnEl){
  const { data: { user } } = await client.auth.getUser();
  if (!user) return false;

  let proof = {};
  try {
    if (q.validation === 'route_selection') {
      const need  = q.payload?.count ?? 1;
      const color = q.payload?.color ?? 'gul';
      const selectedIds = await openRoutePicker(need, color);
      proof.route_ids = selectedIds;

    } else if (q.validation === 'video_capture') {
      const minSek = Math.max(1, Number(q.payload?.min_seconds ?? 3));
      const { ok, meta } = await openVideoProof({ minSeconds: minSek, maxSizeMB: 200 });
      if (!ok) return false;
      proof.video_confirmed = true;
      proof.video_meta = meta;

    } else if (q.validation === 'text') {
      const category   = q.payload?.category || "grebstyper";
      const minmatches = Number(q.payload?.min_matches ?? 1);
      const prompt     = q.payload?.prompt || `Skriv mindst ${minmatches} ord fra ${category}.`;

      let keywords = await getKeywords(category);
      if ((!keywords || !keywords.length) && Array.isArray(q.payload?.keywords)) {
        keywords = q.payload.keywords;
      }
      if (!keywords || !keywords.length) {
        alert(`Ingen keywords fundet i 'keywords.${category}'.`);
        return false;
      }
      const { ok, text, matched_keywords } =
        await openTextProof({ prompt, keywords, min_matches: minmatches });
      if (!ok) return false;

      proof.text_answer  = text;
      proof.text_matched = matched_keywords;
    }

  } catch (e) {
    if (e && e.message === 'cancelled') return false; // bruger lukkede modalen
    alert(e.message || 'Noget gik galt');
    return false;
  }

  // Opret completion
  const { data: uqRow, error } = await client
    .from('user_quests')
    .insert({
      user_id: user.id,
      quest_id: q.id,
      status: 'completed',
      proof,
      completed_at: new Date().toISOString()
    })
    .select()
    .single();

  if (error) {
    // Hvis constraint rammer, s√• opf√∏r dig p√¶nt i UI‚Äôet
    if (String(error.message).includes('uq_user_completed_quest_once')) {
      if (btnEl) { btnEl.disabled = true; btnEl.textContent = 'Allerede fuldf√∏rt'; }
      return true; // behandl som success i UI
    }
    alert(error.message);
    return false;
  }

  // Award XP
  const { error: e3 } = await client.rpc('award_xp_for_quest', {
    p_user_quest_id: uqRow.id
  });
  if (e3) { alert(e3.message); return false; }

  // UI instant + reload
  if (btnEl) { btnEl.disabled = true; btnEl.textContent = 'Allerede fuldf√∏rt'; }
  alert(`F√¶rdig! Du fik +${q.xp_reward} XP`);
  load();
  return true;
}

async function getKeywords(category) {
  // henter kun den √∏nskede kategori (case-insensitive)
  const { data, error } = await client
    .from("keywords")
    .select("terms")
    .ilike("category", category); // 'grebstyper' matcher 'grebstyper' uanset case

  if (error) {
    console.error("Keyword fetch error", error);
    return [];
  }
  if (!Array.isArray(data) || data.length === 0) return [];

  const out = [];

  for (const row of data) {
    let val = row?.terms;

    if (Array.isArray(val)) {
      // ‚úÖ allerede text[] ‚Üí direkte brug
      out.push(...val);
      continue;
    }

    if (typeof val === "string") {
      // Eksemplet viser: "\"{...}\"" (dvs. array-litteral pakket som tekst med ekstra "" omkring)
      let s = val.trim();

      // fjern ydre anf√∏rselstegn hvis tilstede:  "\"{...}\""  ->  "{...}"
      if ((s.startsWith('"') && s.endsWith('"')) || (s.startsWith("'") && s.endsWith("'"))) {
        s = s.slice(1, -1);
      }

      // nu forventer vi Postgres array-litteral: { "a","b","c" } eller {a,b,c}
      if (s.startsWith("{") && s.endsWith("}")) {
        // pr√∏v at hente kun elementer i anf√∏rselstegn (sikrest)
        const quoted = [...s.matchAll(/"((?:[^"\\]|\\.)*)"/g)].map(m => m[1]);
        if (quoted.length) {
          out.push(...quoted);
        } else {
          // fallback: split p√• komma
          out.push(...s.slice(1, -1).split(",").map(x => x.trim()).filter(Boolean));
        }
      } else {
        // sidste udvej: fors√∏g JSON-parse hvis det ligner ["a","b"]
        try {
          const parsed = JSON.parse(s);
          if (Array.isArray(parsed)) out.push(...parsed);
        } catch {}
      }
    }
  }

  // rens + dedup
  return Array.from(new Set(out.map(x => (x || "").toString().trim()).filter(Boolean)));
}

load();
</script>
</body>
</html>
